<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Te:PhiPlayer</title>
    <style>
        @font-face{font-family:'PhigrosFont';src:url('font.ttf') format('truetype');font-weight:normal;font-style:normal;}
        body{background-color:#2a2d3e;color:white;text-align:center;font-family:'PhigrosFont',Arial,sans-serif;margin:0;padding:20px;}
        .container{max-width:800px;margin:0 auto;}
        .controls{margin:20px 0;}
        button{background:#6a11cb;color:white;border:none;padding:10px 20px;margin:5px;border-radius:5px;cursor:pointer;font-family:'PhigrosFont',Arial,sans-serif;font-size:16px;}
        input[type="text"],input[type="file"]{padding:8px;margin:5px;border-radius:4px;border:1px solid #555;background:#3a3d4e;color:white;font-family:'PhigrosFont',Arial,sans-serif;}
        canvas{background:transparent;display:block;margin:0 auto;border:5px solid black;}
        .time-display{font-size:24px;margin:10px 0;font-family:'PhigrosFont','Courier New',monospace;background:rgba(0,0,0,0.5);padding:10px;border-radius:8px;display:inline-block;}
        .slider-container{display:flex;align-items:center;justify-content:center;margin:10px 0;gap:10px;}
        .slider-container label{min-width:80px;text-align:right;}
        input[type="range"]{width:150px;}
        .slider-value{min-width:40px;text-align:left;}
        .credits{margin-top:30px;text-align:left;display:inline-block;background:rgba(0,0,0,0.3);padding:20px;border-radius:10px;}
        a{color:#e74c3c;text-decoration:none;font-weight:bold;}
        .file-upload-section,.player-section{background:rgba(0,0,0,0.3);padding:20px;border-radius:10px;margin:20px 0;}
        #fullscreenBtn{margin-top:10px;}
        .hidden{display:none;}
        .loading{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);padding:20px;border-radius:10px;z-index:1000;}
        #audioControl{display:none;}
    </style>
</head>
<body>
    <div class="container">
        <h1><font color="blue">TE PHIPLAYER</font></h1>
        <a href="https://www.youtube.com/channel/UCbAQhWCCpxHYH2LYihujbIA">欢迎使用Te:PhiPlayer，点击去订阅</a>
        
        <div class="file-upload-section">
            <h2>选择谱面压缩包文件</h2>
            <input type="file" id="zipFile" accept=".zip,.pez,.tpe"><br>
            输入谱面名称：<input type="text" id="chartName"><br>
            输入谱面难度：<input type="text" id="chartDifficulty"><br>
        </div>
        
        <div class="player-section">
            <div class="controls">
                <button onclick="start()">播放，启动！！！</button>
                <button id="pauseBtn" onclick="pause()">暂停</button>
                <button onclick="reset()">重开</button>
                <button onclick="exIt()">退了不玩了</button><br>
                <div class="time-display" id="timeDisplay">00:00.000</div>
                <div class="slider-container"><label for="speedControl">流速倍率:</label><input type="range" id="speedControl" min="0.1" max="5" step="0.1" value="1"><span id="speedValue">1.0</span></div>
                <div class="slider-container"><label for="noteSizeControl">Note大小:</label><input type="range" id="noteSizeControl" min="50" max="150" step="5" value="75"><span id="noteSizeValue">75%</span></div>
            </div>
            <div id="playerContainer">
                <canvas id="player" width="720" height="540"></canvas>
                <button id="fullscreenBtn" onclick="toggleFullscreen()">全屏显示</button>
            </div>
        </div>
        
        <div class="credits">
            <h1>致谢名单</h1><p>1. 我自己和我的键盘<br>2. Sublime Text<br>3. GitHub Pages</p>
            <h1>不谢名单</h1><p>1. 反初音未来（QQ2716692964）<br>2. QAQfei</p>
        </div>
    </div>

    <div id="loading" class="loading hidden">加载中...</div>
    <audio id="audioControl"></audio>

    <script>
        // 配置
        const BASE_SPEED = 1200; // 每秒下落1200px
        const CANVAS_WIDTH = 1920;
        const CANVAS_HEIGHT = 1080;

        // Note材质配置
        const NOTE_TEXTURES = {
            1: { single: 'Tap.png', double: 'Tap2.png' },     // Tap
            2: { single: 'Hold.png', double: 'Hold2.png' },   // Hold  
            3: { single: 'Flick.png', double: 'Flick2.png' }, // Flick
            4: { single: 'Drag.png', double: 'Drag2.png' }    // Drag
        };

        // 全局变量
        let currentTime = 0, isRunning = false, startTime = 0, elapsedTime = 0;
        let animationFrameId = null, speedMultiplier = 1, noteSizeFactor = 0.75;
        let ChartJSON = {}, chartContent = null, audioFile = null;
        let renderer = null, audioElement = null;

        // 缓存变量
        let lastRenderTime = 0;
        const frameRate = 60; // 限制帧率
        const frameInterval = 1000 / frameRate;

        // 预加载的图片
        const noteTextures = {};
        const judgeLineTextures = {};

        class PhigrosRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.canvas.width = 720;
                this.canvas.height = 540;
                
                this.chartData = null;
                this.noteSize = 75;
                
                // 性能优化：缓存常用计算
                this.canvasHalfWidth = this.canvas.width / 2;
                this.canvasHalfHeight = this.canvas.height / 2;
                
                console.log("渲染器初始化完成");
            }

            // 坐标转换（基于1920x1080）- 优化版本
            transformX(x) {
                return (x + 675) * (this.canvas.width / 1350);
            }

            transformY(y) {
                return this.canvas.height - (y + 450) * (this.canvas.height / 900);
            }

            // 事件值计算 - 添加缓存优化
            calculateEventValue(events, time, defaultValue) {
                if (!events || !Array.isArray(events) || events.length === 0) return defaultValue;
                
                let result = defaultValue;
                
                for (const event of events) {
                    if (time >= event.startTime) {
                        if (time <= event.endTime) {
                            // 事件进行中
                            const progress = (time - event.startTime) / (event.endTime - event.startTime);
                            const eased = this.easing(event.easingType || 1, progress);
                            
                            if (Array.isArray(event.start)) {
                                result = event.start.map((s, i) => s + (event.end[i] - s) * eased);
                            } else {
                                result = event.start + (event.end - event.start) * eased;
                            }
                        } else {
                            // 事件已结束，使用最终值
                            if (Array.isArray(event.end)) {
                                result = [...event.end];
                            } else {
                                result = event.end;
                            }
                        }
                    }
                }
                
                return result;
            }

            easing(type, t) {
                // 使用查表法优化常用缓动函数
                switch(type) {
                    case 1: return t;
                    case 2: return t * t;
                    case 3: return 1 - (1 - t) * (1 - t);
                    case 4: return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    default: return t;
                }
            }

            // 判定线属性计算 - 优化文本处理
            getJudgeLineProperties(judgeLine, time) {
                const props = {
                    x: 0, y: 0, rotation: 0, alpha: 255,
                    scaleX: 1, scaleY: 1, speed: 1,
                    color: [255, 255, 255],
                    anchorX: 0.5, anchorY: 0.5,
                    text: null, textColor: "#ffffff",
                    texture: null
                };

                if (!judgeLine) return props;

                // 事件层
                if (judgeLine.eventLayers) {
                    for (const layer of judgeLine.eventLayers) {
                        if (layer?.moveXEvents) props.x = this.calculateEventValue(layer.moveXEvents, time, props.x);
                        if (layer?.moveYEvents) props.y = this.calculateEventValue(layer.moveYEvents, time, props.y);
                        if (layer?.rotateEvents) props.rotation = this.calculateEventValue(layer.rotateEvents, time, props.rotation);
                        if (layer?.alphaEvents) props.alpha = this.calculateEventValue(layer.alphaEvents, time, props.alpha);
                        if (layer?.speedEvents) props.speed = this.calculateEventValue(layer.speedEvents, time, props.speed);
                    }
                }

                // 扩展属性
                if (judgeLine.extended) {
                    const ext = judgeLine.extended;
                    if (ext.scaleXEvents) props.scaleX = this.calculateEventValue(ext.scaleXEvents, time, 1);
                    if (ext.scaleYEvents) props.scaleY = this.calculateEventValue(ext.scaleYEvents, time, 1);
                    if (ext.anchorEvents) {
                        const anchor = this.calculateEventValue(ext.anchorEvents, time, [0.5, 0.5]);
                        if (Array.isArray(anchor)) {
                            props.anchorX = anchor[0];
                            props.anchorY = anchor[1];
                        }
                    }
                    if (ext.colorEvents) {
                        const color = this.calculateEventValue(ext.colorEvents, time, [255, 255, 255]);
                        if (Array.isArray(color)) props.color = color;
                    }
                    if (ext.textEvents && ext.textEvents.length > 0) {
                        // 找到当前时间对应的文本事件 - 优化查找逻辑
                        let currentTextEvent = null;
                        for (const event of ext.textEvents) {
                            if (time >= event.startTime && time <= event.endTime) {
                                currentTextEvent = event;
                                break;
                            } else if (time > event.endTime) {
                                // 记录最后一个结束的事件
                                if (!currentTextEvent || event.endTime > currentTextEvent.endTime) {
                                    currentTextEvent = event;
                                }
                            }
                        }
                        
                        if (currentTextEvent) {
                            if (time <= currentTextEvent.endTime) {
                                // 事件进行中 - 文本实时变化
                                const progress = (time - currentTextEvent.startTime) / (currentTextEvent.endTime - currentTextEvent.startTime);
                                const eased = this.easing(currentTextEvent.easingType || 1, progress);
                                
                                if (Array.isArray(currentTextEvent.start)) {
                                    props.text = currentTextEvent.start.map((s, i) => 
                                        s + (currentTextEvent.end[i] - s) * eased
                                    ).join('');
                                } else {
                                    props.text = currentTextEvent.start + (currentTextEvent.end - currentTextEvent.start) * eased;
                                }
                            } else {
                                // 事件已结束，使用最终值
                                props.text = Array.isArray(currentTextEvent.end) ? 
                                    currentTextEvent.end.join('') : currentTextEvent.end;
                            }
                            
                            props.textColor = `rgb(${props.color[0]}, ${props.color[1]}, ${props.color[2]})`;
                        }
                    }
                }

                // 判定线材质
                if (judgeLine.Texture) {
                    props.texture = judgeLineTextures[judgeLine.Texture];
                }

                if (judgeLine.bpmfactor) props.speed /= judgeLine.bpmfactor;
                props.alpha = Math.max(0, Math.min(255, props.alpha));

                return props;
            }

            // 判定线渲染 - 优化性能
            renderJudgeLine(judgeLine, time) {
                if (!judgeLine) return;

                const props = this.getJudgeLineProperties(judgeLine, time);
                
                // 判定线透明度小于0时不渲染
                if (props.alpha < 0) return;

                this.ctx.save();
                this.ctx.globalAlpha = props.alpha / 255;

                const x = this.transformX(props.x);
                const y = this.transformY(props.y);

                this.ctx.translate(x, y);
                this.ctx.rotate(props.rotation * Math.PI / 180);

                // 判定线尺寸
                const width = 2000 * props.scaleX;
                const height = 10 * props.scaleY;

                // 应用锚点偏移
                const anchorOffsetX = width * (0.5 - props.anchorX);
                const anchorOffsetY = height * (0.5 - props.anchorY);

                // 渲染判定线材质
                if (props.texture && props.texture.complete && props.texture.width > 0) {
                    if (props.scaleX === 1 && props.scaleY === 1) {
                        // 没有缩放：使用材质最中间的一个像素铺满屏幕
                        const centerX = Math.floor(props.texture.width / 2);
                        const centerY = Math.floor(props.texture.height / 2);
                        
                        // 获取中心像素颜色
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = 1;
                        tempCanvas.height = 1;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(props.texture, centerX, centerY, 1, 1, 0, 0, 1, 1);
                        
                        const imageData = tempCtx.getImageData(0, 0, 1, 1);
                        const color = `rgba(${imageData.data[0]}, ${imageData.data[1]}, ${imageData.data[2]}, ${imageData.data[3] / 255})`;
                        
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(-this.canvas.width, -this.canvas.height, this.canvas.width * 2, this.canvas.height * 2);
                    } else {
                        // 有缩放：按照缩放后的材质大小显示
                        const textureWidth = props.texture.width * props.scaleX;
                        const textureHeight = props.texture.height * props.scaleY;
                        
                        this.ctx.drawImage(props.texture, 
                            -textureWidth/2 - anchorOffsetX, 
                            -textureHeight/2 - anchorOffsetY, 
                            textureWidth, 
                            textureHeight);
                    }
                } else {
                    // 没有材质或材质加载失败：绘制普通判定线
                    if (!props.text) {
                        this.ctx.fillStyle = `rgb(${props.color[0]}, ${props.color[1]}, ${props.color[2]})`;
                        this.ctx.fillRect(-width/2 - anchorOffsetX, -height/2 - anchorOffsetY, width, height);
                    }
                }

                // 绘制文字（文本可以实时变化）
                if (props.text) {
                    this.ctx.save();
                    this.ctx.translate(anchorOffsetX, anchorOffsetY);
                    
                    this.ctx.fillStyle = props.textColor;
                    this.ctx.font = '20px PhigrosFont';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(props.text, 0, -20);
                    
                    this.ctx.restore();
                }

                this.ctx.restore();
            }

            // 检查Note是否应该显示 - 优化性能
            shouldNoteBeVisible(note, judgeProps, time) {
                // 快速检查
                if (judgeProps.alpha < 0) return false;
                
                const noteAlpha = note.alpha !== undefined ? note.alpha : 255;
                if (noteAlpha <= 0) return false;
                
                const startTime = note.startTime || 0;
                const timeToHit = startTime - time;
                const visibleTime = note.visibleTime || 2;
                
                if (visibleTime < 75000) {
                    if (timeToHit > visibleTime || timeToHit < -0.5) {
                        return false;
                    }
                }
                
                if (note.endTime && time > note.endTime) {
                    return false;
                }
                
                return true;
            }

            // Note渲染 - 优化性能
            renderNote(note, judgeLine, time) {
                if (!note || !judgeLine) return;

                const judgeProps = this.getJudgeLineProperties(judgeLine, time);
                
                if (!this.shouldNoteBeVisible(note, judgeProps, time)) {
                    return;
                }

                // 检查是否为0速note
                const isZeroSpeedNote = (note.speed <= 0) || (judgeProps.speed <= 0) || (note.visibleTime <= 0);
                
                if (isZeroSpeedNote) {
                    this.renderZeroSpeedNote(note, judgeLine, time);
                    return;
                }

                const startTime = note.startTime || 0;
                const timeToHit = startTime - time;

                // 流速计算
                const speed = (note.speed || 1) * judgeProps.speed * speedMultiplier * BASE_SPEED * 10;
                const distance = timeToHit * speed / 1000;
                const above = note.above !== undefined ? note.above : 1;
                const yOffset = note.yOffset || 0;

                const noteY = judgeProps.y + (above === 1 ? distance : -distance) + yOffset;
                const noteX = judgeProps.x + (note.positionX || 0);
                const x = this.transformX(noteX);
                const y = this.transformY(noteY);

                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(judgeProps.rotation * Math.PI / 180);

                const alpha = note.alpha !== undefined ? note.alpha : 255;
                this.ctx.globalAlpha = alpha / 255;

                this.drawNote(note, judgeProps, time);

                this.ctx.restore();
            }

            // 渲染0速note
            renderZeroSpeedNote(note, judgeLine, time) {
                if (!note || !judgeLine) return;

                const judgeProps = this.getJudgeLineProperties(judgeLine, time);
                
                if (!this.shouldNoteBeVisible(note, judgeProps, time)) {
                    return;
                }

                const noteX = judgeProps.x + (note.positionX || 0);
                const noteY = judgeProps.y;
                const x = this.transformX(noteX);
                const y = this.transformY(noteY);

                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate(judgeProps.rotation * Math.PI / 180);

                const alpha = note.alpha !== undefined ? note.alpha : 255;
                this.ctx.globalAlpha = alpha / 255;

                this.drawNote(note, judgeProps, time, true);

                this.ctx.restore();
            }

            // 绘制Note - 优化性能
            drawNote(note, judgeProps, time, isZeroSpeed = false) {
                const baseSize = this.noteSize * noteSizeFactor;
                const size = (note.size || 1) * baseSize;
                const noteType = note.type || 1;
                const isDouble = note.isDouble || false;

                const textureInfo = NOTE_TEXTURES[noteType];
                const textureName = textureInfo ? (isDouble ? textureInfo.double : textureInfo.single) : 'Tap.png';
                const texture = noteTextures[textureName];

                if (texture && texture.complete) {
                    const aspectRatio = texture.width / texture.height;
                    let width = size;
                    let height = size;
                    
                    if (aspectRatio > 1) {
                        height = size / aspectRatio;
                    } else {
                        width = size * aspectRatio;
                    }
                    
                    if (noteType === 2) {
                        width *= 2;
                        height /= 4;
                    }
                    
                    this.ctx.drawImage(texture, -width/2, -height/2, width, height);
                } else {
                    const tint = note.tint || [255, 255, 255];
                    this.ctx.fillStyle = `rgb(${tint[0]}, ${tint[1]}, ${tint[2]})`;
                    
                    switch(noteType) {
                        case 1: this.ctx.fillRect(-size/2, -size/2, size, size); break;
                        case 2: this.ctx.fillRect(-size, -size/8, size*2, size/4); break;
                        case 3: 
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                            this.ctx.fill();
                            break;
                        case 4:
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, -size/2);
                            this.ctx.lineTo(size/2, 0);
                            this.ctx.lineTo(0, size/2);
                            this.ctx.lineTo(-size/2, 0);
                            this.ctx.closePath();
                            this.ctx.fill();
                            break;
                        default: this.ctx.fillRect(-size/2, -size/2, size, size);
                    }
                }
            }

            // 主渲染循环 - 优化性能
            render(time) {
                const now = Date.now();
                if (now - lastRenderTime < frameInterval) return;
                lastRenderTime = now;

                // 清空画布
                this.ctx.fillStyle = '#2a2d3e';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (!this.chartData || !this.chartData.judgeLineList) return;

                try {
                    // 按zOrder排序
                    const judgeLines = [...this.chartData.judgeLineList]
                        .map((line, index) => ({ line, index }))
                        .sort((a, b) => {
                            const zOrderA = a.line.zOrder || 0;
                            const zOrderB = b.line.zOrder || 0;
                            if (zOrderA !== zOrderB) return zOrderA - zOrderB;
                            return a.index - b.index;
                        })
                        .map(item => item.line);

                    // 渲染判定线
                    for (const judgeLine of judgeLines) {
                        this.renderJudgeLine(judgeLine, time);
                    }

                    // 收集所有音符
                    const allNotes = [];
                    for (const judgeLine of judgeLines) {
                        if (judgeLine.notes) {
                            for (const note of judgeLine.notes) {
                                allNotes.push({ note, judgeLine });
                            }
                        }
                    }
                    allNotes.sort((a, b) => (a.note.zIndex || 0) - (b.note.zIndex || 0));

                    // 渲染音符
                    for (const { note, judgeLine } of allNotes) {
                        this.renderNote(note, judgeLine, time);
                    }

                } catch (error) {
                    console.error('渲染错误:', error);
                }
            }

            setChartData(chartData) {
                this.chartData = chartData;
            }

            setNoteSize(factor) {
                this.noteSize = 75 * factor * 2;
            }
        }

        // 工具函数
        function beatToValue(beat) {
            if (!Array.isArray(beat) || beat.length < 3) return 0;
            return beat[0] + beat[1] / (beat[2] || 1);
        }

        function beat2sec(BPMList, beat, bpmfactor = 1) {
            if (!BPMList) return 0;
            
            let targetBeat = beatToValue(beat);
            let sec = 0;
            let remainingBeat = targetBeat;
            
            for (let i = 0; i < BPMList.length; i++) {
                const bpm = BPMList[i];
                if (!bpm || typeof bpm.bpm !== 'number') continue;
                
                const bpmValue = bpm.bpm / bpmfactor;
                const currentStart = beatToValue(bpm.startTime || [0, 0, 1]);
                
                if (i < BPMList.length - 1) {
                    const nextBPM = BPMList[i + 1];
                    if (!nextBPM) continue;
                    const nextStart = beatToValue(nextBPM.startTime || [0, 0, 1]);
                    const segmentLength = nextStart - currentStart;
                    
                    if (remainingBeat > segmentLength) {
                        sec += segmentLength * (60 / bpmValue);
                        remainingBeat -= segmentLength;
                    } else {
                        sec += remainingBeat * (60 / bpmValue);
                        remainingBeat = 0;
                        break;
                    }
                } else {
                    sec += remainingBeat * (60 / bpmValue);
                    break;
                }
            }
            return sec;
        }

        function allbeat2sec(rpeData) {
            if (!rpeData) return rpeData;
            
            try {
                const result = JSON.parse(JSON.stringify(rpeData));
                
                function processObject(obj) {
                    if (!obj || typeof obj !== 'object') return;
                    
                    for (let key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            if ((key === "startTime" || key === "endTime") && Array.isArray(obj[key])) {
                                obj[key] = beat2sec(rpeData.BPMList, obj[key]);
                            } else if (typeof obj[key] === "object") {
                                processObject(obj[key]);
                            }
                        }
                    }
                }
                
                for (let key in result) {
                    if (key !== "BPMList" && typeof result[key] === "object") {
                        processObject(result[key]);
                    }
                }
                
                return result;
            } catch (error) {
                console.error("谱面时间转换错误:", error);
                return rpeData;
            }
        }

        function formatTime(time) {
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            const milliseconds = Math.floor((time * 1000) % 1000);
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }

        // 预加载材质
        function preloadTextures() {
            const texturePromises = [];
            
            for (const [type, textures] of Object.entries(NOTE_TEXTURES)) {
                for (const [key, filename] of Object.entries(textures)) {
                    const img = new Image();
                    noteTextures[filename] = img;
                    
                    texturePromises.push(new Promise((resolve) => {
                        img.onload = resolve;
                        img.onerror = () => {
                            console.warn(`无法加载Note材质: ${filename}`);
                            resolve();
                        };
                        img.src = `./assets/${filename}`;
                    }));
                }
            }
            
            return Promise.all(texturePromises);
        }

        // 从ZIP加载判定线材质
        async function loadJudgeLineTexturesFromZip() {
            const texturePromises = [];
            
            for (const [path, url] of Object.entries(ChartJSON)) {
                if (path.match(/\.(png|jpg|jpeg|gif|bmp|webp)$/i)) {
                    const img = new Image();
                    judgeLineTextures[path] = img;
                    
                    texturePromises.push(new Promise((resolve) => {
                        img.onload = resolve;
                        img.onerror = () => {
                            if (path !== 'line.png') {
                                console.warn(`无法加载判定线材质: ${path}`);
                            }
                            resolve();
                        };
                        img.src = url;
                    }));
                }
            }
            
            return Promise.all(texturePromises);
        }

        // 音频控制
        function setupAudio(songFile) {
            if (audioElement) {
                audioElement.pause();
                audioElement = null;
            }
            
            if (songFile && ChartJSON[songFile]) {
                audioElement = document.getElementById('audioControl');
                audioElement.src = ChartJSON[songFile];
                audioElement.load();
                
                audioElement.addEventListener('canplaythrough', () => {
                    console.log('音频加载完成');
                });
                
                audioElement.addEventListener('error', (e) => {
                    console.error('音频加载失败:', e);
                });
            }
        }

        // 控制函数
        function init() {
            const canvas = document.getElementById('player');
            if (!canvas) return;
            
            renderer = new PhigrosRenderer(canvas);
            console.log("播放器初始化完成");
        }

        function start() {
            if (!chartContent) {
                alert("请先加载谱面文件");
                return;
            }

            try {
                const chartData = JSON.parse(chartContent);
                const convertedData = allbeat2sec(chartData);
                
                if (renderer) {
                    renderer.setChartData(convertedData);
                    renderer.setNoteSize(noteSizeFactor);
                }
                
                if (!isRunning) {
                    isRunning = true;
                    startTime = Date.now() - elapsedTime;
                    lastRenderTime = Date.now();
                    
                    // 播放音频
                    if (audioFile) {
                        setupAudio(audioFile);
                        if (audioElement) {
                            audioElement.currentTime = currentTime;
                            audioElement.play().catch(e => {
                                console.warn('自动播放被阻止:', e);
                            });
                        }
                    }
                    
                    function animate() {
                        if (!isRunning) return;
                        
                        const now = Date.now();
                        elapsedTime = now - startTime;
                        currentTime = elapsedTime / 1000;
                        
                        document.getElementById('timeDisplay').textContent = formatTime(currentTime);
                        
                        if (renderer) {
                            renderer.render(currentTime);
                        }
                        
                        // 同步音频
                        if (audioElement && Math.abs(audioElement.currentTime - currentTime) > 0.1) {
                            audioElement.currentTime = currentTime;
                        }
                        
                        animationFrameId = requestAnimationFrame(animate);
                    }
                    
                    animate();
                }
            } catch (e) {
                console.error("解析JSON失败:", e);
                alert("谱面数据格式错误");
            }
        }

        function pause() {
            const pauseBtn = document.getElementById('pauseBtn');
            if (isRunning) {
                isRunning = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                if (audioElement) {
                    audioElement.pause();
                }
                elapsedTime = Date.now() - startTime;
                pauseBtn.textContent = "继续";
            } else {
                isRunning = true;
                startTime = Date.now() - elapsedTime;
                if (audioElement) {
                    audioElement.play().catch(e => {
                        console.warn('音频播放失败:', e);
                    });
                }
                pauseBtn.textContent = "暂停";
                requestAnimationFrame(function animate() {
                    if (!isRunning) return;
                    
                    const now = Date.now();
                    elapsedTime = now - startTime;
                    currentTime = elapsedTime / 1000;
                    
                    document.getElementById('timeDisplay').textContent = formatTime(currentTime);
                    
                    if (renderer) {
                        renderer.render(currentTime);
                    }
                    
                    animationFrameId = requestAnimationFrame(animate);
                });
            }
        }

        function reset() {
            isRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (audioElement) {
                audioElement.pause();
                audioElement.currentTime = 0;
            }
            elapsedTime = 0;
            currentTime = 0;
            document.getElementById('timeDisplay').textContent = "00:00.000";
            document.getElementById('pauseBtn').textContent = "暂停";
            
            if (renderer && chartContent) {
                try {
                    const chartData = JSON.parse(chartContent);
                    const convertedData = allbeat2sec(chartData);
                    renderer.setChartData(convertedData);
                    renderer.render(0);
                } catch (e) {
                    console.error("重置失败:", e);
                }
            }
        }

        function exIt() {
            isRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (audioElement) {
                audioElement.pause();
                audioElement = null;
            }
            elapsedTime = 0;
            currentTime = 0;
            document.getElementById('timeDisplay').textContent = "00:00.000";
            document.getElementById('pauseBtn').textContent = "暂停";
            
            if (renderer) {
                renderer.setChartData(null);
                renderer.render(0);
            }
        }

        function toggleFullscreen() {
            const container = document.getElementById('playerContainer');
            const canvas = document.getElementById('player');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            if (!document.fullscreenElement) {
                container.requestFullscreen().then(() => {
                    fullscreenBtn.style.display = 'none';
                    canvas.style.width = '100vw';
                    canvas.style.height = '100vh';
                });
            } else {
                document.exitFullscreen().then(() => {
                    fullscreenBtn.style.display = 'block';
                    canvas.style.width = '720px';
                    canvas.style.height = '540px';
                });
            }
        }

        // 文件处理
        async function handleZipFile(file) {
            if (!file) {
                alert("请选择有效的ZIP文件");
                return;
            }
            
            if (typeof JSZip === 'undefined') {
                alert("JSZip库未加载");
                return;
            }
            
            try {
                document.getElementById('loading').classList.remove('hidden');
                
                const zip = new JSZip();
                const contents = await zip.loadAsync(file);
                
                const promises = [];
                contents.forEach((path, entry) => {
                    if (!entry.dir) {
                        promises.push(entry.async('blob').then(blob => {
                            ChartJSON[path] = URL.createObjectURL(blob);
                        }));
                    }
                });
                
                await Promise.all(promises);
                
                await loadJudgeLineTexturesFromZip();
                await InfoRequest();
                
            } catch (err) {
                console.error("ZIP文件处理失败:", err);
                alert("ZIP文件处理失败");
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }

        async function InfoRequest() {
            if (ChartJSON['info.txt']) {
                try {
                    const response = await fetch(ChartJSON['info.txt']);
                    const text = await response.text();
                    
                    const chartInfo = {};
                    const lines = text.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('#')) continue; // 跳过注释
                        const match = line.match(/(\w+):\s*(.+)/);
                        if (match) {
                            const key = match[1].trim();
                            const value = match[2].trim();
                            chartInfo[key] = value;
                            
                            // 检测音频文件
                            if (key.toLowerCase() === 'song') {
                                audioFile = value;
                                console.log('检测到音频文件:', audioFile);
                            }
                        }
                    }
                    
                    document.getElementById('chartName').value = chartInfo.Name || '';
                    document.getElementById('chartDifficulty').value = chartInfo.Level || '';
                    
                    if (chartInfo.Chart && ChartJSON[chartInfo.Chart]) {
                        const chartResponse = await fetch(ChartJSON[chartInfo.Chart]);
                        chartContent = await chartResponse.text();
                        console.log("谱面文件加载完成");
                    }
                } catch (err) {
                    console.error("加载谱面信息失败:", err);
                }
            }
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 预加载材质
            preloadTextures().then(() => {
                console.log("材质预加载完成");
            });

            // 流速控制
            const speedControl = document.getElementById('speedControl');
            const speedValue = document.getElementById('speedValue');
            speedControl.addEventListener('input', function() {
                speedMultiplier = parseFloat(this.value);
                speedValue.textContent = speedMultiplier.toFixed(1);
            });
            
            // Note大小控制
            const noteSizeControl = document.getElementById('noteSizeControl');
            const noteSizeValue = document.getElementById('noteSizeValue');
            noteSizeControl.addEventListener('input', function() {
                noteSizeFactor = parseFloat(this.value) / 100;
                noteSizeValue.textContent = this.value + '%';
                if (renderer) {
                    renderer.setNoteSize(noteSizeFactor);
                }
            });
            
            // 文件选择
            const zipFileInput = document.getElementById('zipFile');
            zipFileInput.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (file) {
                    handleZipFile(file);
                }
            });
            
            // 初始化播放器
            init();
        });

    </script>
    <script src="js/jszip.min.js"></script>
</body>
</html>