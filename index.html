<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Te:PhiPlayer 1.0.1</title>
    <style>
        @font-face{font-family:'PhigrosFont';src:url('font.ttf') format('truetype');font-weight:normal;font-style:normal;}
        body{background-color:#2a2d3e;color:white;text-align:center;font-family:'PhigrosFont',Arial,sans-serif;margin:0;padding:20px;}
        .container{max-width:800px;margin:0 auto;}
        .controls{margin:20px 0;}
        button{background:#6a11cb;color:white;border:none;padding:10px 20px;margin:5px;border-radius:5px;cursor:pointer;font-family:'PhigrosFont',Arial,sans-serif;font-size:16px;}
        input[type="text"],input[type="file"]{padding:8px;margin:5px;border-radius:4px;border:1px solid #555;background:#3a3d4e;color:white;font-family:'PhigrosFont',Arial,sans-serif;}
        canvas{background:transparent;display:block;margin:0 auto;border:5px solid black;}
        .time-display{font-size:24px;margin:10px 0;font-family:'PhigrosFont','Courier New',monospace;background:rgba(0,0,0,0.5);padding:10px;border-radius:8px;display:inline-block;}
        .slider-container{display:flex;align-items:center;justify-content:center;margin:10px 0;gap:10px;}
        .slider-container label{min-width:80px;text-align:right;}
        input[type="range"]{width:150px;}
        .slider-value{min-width:40px;text-align:left;}
        .credits{margin-top:30px;text-align:left;display:inline-block;background:rgba(0,0,0,0.3);padding:20px;border-radius:10px;}
        a{color:#e74c3c;text-decoration:none;font-weight:bold;}
        .file-upload-section,.player-section{background:rgba(0,0,0,0.3);padding:20px;border-radius:10px;margin:20px 0;}
        #fullscreenBtn{margin-top:10px;}
        .hidden{display:none;}
        .loading{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);padding:20px;border-radius:10px;z-index:1000;}
        #audioControl{display:none;}
    </style>
</head>
<body>
    <div class="container">
        <h1><font color="blue">TE PHIPLAYER</font></h1>
        <a href="https://www.youtube.com/channel/UCbAQhWCCpxHYH2LYihujbIA">欢迎使用Te:PhiPlayer，点击去订阅</a>
        
        <div class="file-upload-section">
            <h2>选择谱面压缩包文件</h2>
            <input type="file" id="zipFile" accept=".zip,.pez,.tpe"><br>
            输入谱面名称：<input type="text" id="chartName"><br>
            输入谱面难度：<input type="text" id="chartDifficulty"><br>
        </div>
        
        <div class="player-section">
            <div class="controls">
                <button onclick="start()">播放</button>
                <button id="pauseBtn" onclick="pause()">暂停</button>
                <button onclick="reset()">重开</button>
                <button onclick="exIt()">退出</button><br>
                <div class="time-display" id="timeDisplay">00:00.000</div>
                <div class="time-display" id="hitNoteDisplay">已过线Note: 0</div>
                <div class="slider-container"><label>流速:</label><input type="range" id="speedControl" min="1" max="10" step="0.1" value="1"><span id="speedValue">1.0</span></div>
                <div class="slider-container"><label>大小:</label><input type="range" id="noteSizeControl" min="50" max="150" step="5" value="75"><span id="noteSizeValue">75%</span></div>
            </div>
            <div id="playerContainer">
                <canvas id="player" width="720" height="540"></canvas>
                <button id="fullscreenBtn" onclick="toggleFullscreen()">全屏</button>
            </div>
        </div>
    </div>

    <div id="loading" class="loading hidden">加载中...</div>
    <audio id="audioControl"></audio>

    <script>
        // 配置
        const BASE_SPEED = 1200;
        const NOTE_TEXTURES = {
            1: { single: 'Tap.png', double: 'Tap2.png' },
            2: { single: 'Hold.png', double: 'Hold2.png' },  
            3: { single: 'Flick.png', double: 'Flick2.png' },
            4: { single: 'Drag.png', double: 'Drag2.png' }
        };

        // 全局变量
        let currentTime = 0, isRunning = false, startTime = 0, elapsedTime = 0;
        let animationFrameId = null, speedMultiplier = 1, noteSizeFactor = 0.75;
        let ChartJSON = {}, chartContent = null, audioFile = null;
        let renderer = null, audioElement = null;
        let hitNoteCount = 0;
        let isInitialized = false;
        let chartData = null;

        // 材质
        const noteTextures = {};
        const judgeLineTextures = {};

        class PhigrosRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { alpha: false });
                this.canvas.width = 720;
                this.canvas.height = 540;
                this.chartData = null;
                this.noteSize = 75;
                this.transformXFactor = this.canvas.width / 1350;
                this.transformYFactor = this.canvas.height / 900;
                this.canvasHeight = this.canvas.height;
            }

            transformX(x) { return (x + 675) * this.transformXFactor; }
            transformY(y) { return this.canvasHeight - (y + 450) * this.transformYFactor; }

            calculateEventValue(events, time, defaultValue) {
                if (!events || events.length === 0) return defaultValue;
                let result = defaultValue;
                for (let i = 0; i < events.length; i++) {
                    const event = events[i];
                    if (time >= event.startTime) {
                        if (time <= event.endTime) {
                            const progress = (time - event.startTime) / (event.endTime - event.startTime);
                            const eased = this.easing(event.easingType || 1, progress);
                            if (Array.isArray(event.start)) {
                                result = event.start.map((s, i) => s + (event.end[i] - s) * eased);
                            } else {
                                result = event.start + (event.end - event.start) * eased;
                            }
                        } else {
                            result = Array.isArray(event.end) ? [...event.end] : event.end;
                        }
                    }
                }
                return result;
            }

            easing(type, t) {
                switch(type) {
                    case 1: return t;
                    case 2: return t * t;
                    case 3: return 1 - (1 - t) * (1 - t);
                    case 4: return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    default: return t;
                }
            }

            getJudgeLinePropertiesWithParent(judgeLine, time, parentProps = null) {
                let props = {
                    x: 0, y: 0, rotation: 0, alpha: 255,
                    scaleX: 1, scaleY: 1, speed: 1,
                    color: [255, 255, 255],
                    anchorX: 0.5, anchorY: 0.5,
                    text: null, textColor: "#ffffff",
                    texture: null,
                    parentRotation: 0
                };

                if (!judgeLine) return props;
                if (parentProps) {
                    props.x = parentProps.x;
                    props.y = parentProps.y;
                    props.rotation = parentProps.rotation;
                    props.parentRotation = parentProps.rotation + (parentProps.parentRotation || 0);
                    props.alpha = parentProps.alpha;
                    props.scaleX = parentProps.scaleX;
                    props.scaleY = parentProps.scaleY;
                    props.speed = parentProps.speed;
                    props.color = [...parentProps.color];
                }

                if (judgeLine.eventLayers) {
                    for (let i = 0; i < judgeLine.eventLayers.length; i++) {
                        const layer = judgeLine.eventLayers[i];
                        if (layer?.moveXEvents) props.x += this.calculateEventValue(layer.moveXEvents, time, 0);
                        if (layer?.moveYEvents) props.y += this.calculateEventValue(layer.moveYEvents, time, 0);
                        if (layer?.rotateEvents) props.rotation += this.calculateEventValue(layer.rotateEvents, time, 0);
                        if (layer?.alphaEvents) props.alpha = this.calculateEventValue(layer.alphaEvents, time, props.alpha);
                        if (layer?.speedEvents) props.speed = this.calculateEventValue(layer.speedEvents, time, props.speed);
                    }
                }

                if (judgeLine.extended) {
                    const ext = judgeLine.extended;
                    if (ext.scaleXEvents) props.scaleX = this.calculateEventValue(ext.scaleXEvents, time, props.scaleX);
                    if (ext.scaleYEvents) props.scaleY = this.calculateEventValue(ext.scaleYEvents, time, props.scaleY);
                    if (ext.anchorEvents) {
                        const anchor = this.calculateEventValue(ext.anchorEvents, time, [props.anchorX, props.anchorY]);
                        if (Array.isArray(anchor)) { props.anchorX = anchor[0]; props.anchorY = anchor[1]; }
                    }
                    if (ext.colorEvents) {
                        const color = this.calculateEventValue(ext.colorEvents, time, props.color);
                        if (Array.isArray(color)) props.color = color;
                    }
                    // 文字事件处理
                    if (ext.textEvents && ext.textEvents.length > 0) {
                        let currentTextEvent = null;
                        let lastValidEvent = null;
                        
                        for (let i = 0; i < ext.textEvents.length; i++) {
                            const event = ext.textEvents[i];
                            if (time >= event.startTime) {
                                if (time <= event.endTime) {
                                    currentTextEvent = event;
                                    break;
                                } else {
                                    lastValidEvent = event;
                                }
                            }
                        }
                        
                        if (currentTextEvent) {
                            const progress = (time - currentTextEvent.startTime) / (currentTextEvent.endTime - currentTextEvent.startTime);
                            const eased = this.easing(currentTextEvent.easingType || 1, progress);
                            
                            if (Array.isArray(currentTextEvent.start)) {
                                props.text = currentTextEvent.start.map((s, i) => {
                                    const startStr = String(s);
                                    const endStr = String(currentTextEvent.end[i]);
                                    return eased < 0.5 ? startStr : endStr;
                                }).join('');
                            } else {
                                const startStr = String(currentTextEvent.start);
                                const endStr = String(currentTextEvent.end);
                                props.text = eased < 0.5 ? startStr : endStr;
                            }
                            props.textColor = `rgb(${props.color[0]}, ${props.color[1]}, ${props.color[2]})`;
                        } else if (lastValidEvent) {
                            // 文字事件结束后保留最后的文字
                            props.text = Array.isArray(lastValidEvent.end) ? 
                                lastValidEvent.end.join('') : 
                                String(lastValidEvent.end);
                            props.textColor = `rgb(${props.color[0]}, ${props.color[1]}, ${props.color[2]})`;
                        }
                    }
                }

                if (judgeLine.Texture) props.texture = judgeLineTextures[judgeLine.Texture];
                if (judgeLine.bpmfactor) props.speed /= judgeLine.bpmfactor;
                props.alpha = Math.max(0, Math.min(255, props.alpha));
                return props;
            }

            renderJudgeLine(judgeLine, time, parentProps = null) {
                if (!judgeLine) return;
                const props = this.getJudgeLinePropertiesWithParent(judgeLine, time, parentProps);
                
                // linealpha < 0 时不渲染判定线，但仍然渲染note
                if (props.alpha <= 0) {
                    // 只渲染note，不渲染判定线
                    this.renderNotesOnly(judgeLine, time, parentProps);
                    return;
                }

                this.ctx.save();
                this.ctx.globalAlpha = props.alpha / 255;
                const x = this.transformX(props.x);
                const y = this.transformY(props.y);
                this.ctx.translate(x, y);
                this.ctx.rotate((props.rotation + props.parentRotation) * Math.PI / 180);

                // 只有当没有文字时才渲染判定线图形
                if (!props.text) {
                    const width = 2000 * props.scaleX;
                    const height = 10 * props.scaleY;
                    const anchorOffsetX = width * (0.5 - props.anchorX);
                    const anchorOffsetY = height * (0.5 - props.anchorY);

                    if (props.texture && props.texture.complete) {
                        let textureWidth = props.texture.width * props.scaleX;
                        let textureHeight = props.texture.height * props.scaleY;
                        if (judgeLine.Texture !== 'line.png') { textureWidth /= 2; textureHeight /= 2; }
                        this.ctx.drawImage(props.texture, -textureWidth/2 - anchorOffsetX, -textureHeight/2 - anchorOffsetY, textureWidth, textureHeight);
                    } else {
                        this.ctx.fillStyle = `rgb(${props.color[0]}, ${props.color[1]}, ${props.color[2]})`;
                        this.ctx.fillRect(-width/2 - anchorOffsetX, -height/2 - anchorOffsetY, width, height);
                    }
                }

                // 渲染文字
                if (props.text) {
                    this.ctx.save();
                    this.ctx.fillStyle = props.textColor;
                    this.ctx.font = '20px PhigrosFont';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(props.text, 0, -20);
                    this.ctx.restore();
                }

                this.ctx.restore();

                // 渲染子判定线
                if (judgeLine.judgeLineList) {
                    for (let i = 0; i < judgeLine.judgeLineList.length; i++) {
                        this.renderJudgeLine(judgeLine.judgeLineList[i], time, props);
                    }
                }

                // 渲染note
                this.renderNotes(judgeLine, time, parentProps);
            }

            renderNotesOnly(judgeLine, time, parentProps = null) {
                if (!judgeLine) return;
                const props = this.getJudgeLinePropertiesWithParent(judgeLine, time, parentProps);
                
                // 渲染当前判定线的note
                this.renderNotes(judgeLine, time, parentProps);
                
                // 递归渲染子判定线的note
                if (judgeLine.judgeLineList) {
                    for (let i = 0; i < judgeLine.judgeLineList.length; i++) {
                        this.renderNotesOnly(judgeLine.judgeLineList[i], time, props);
                    }
                }
            }

            renderNotes(judgeLine, time, parentProps = null) {
                if (!judgeLine || !judgeLine.notes) return;
                const judgeProps = this.getJudgeLinePropertiesWithParent(judgeLine, time, parentProps);
                
                for (let i = 0; i < judgeLine.notes.length; i++) {
                    const note = judgeLine.notes[i];
                    this.renderNote(note, judgeLine, time, parentProps);
                }
            }

            shouldNoteBeVisible(note, judgeProps, time) {
                // 基本可见性检查
                const noteAlpha = note.alpha !== undefined ? note.alpha : 255;
                if (noteAlpha <= 0) return false;
                
                const startTime = note.startTime || 0;
                const endTime = note.endTime || startTime;
                
                // 检查时间范围
                if (time < startTime - 2 || time > endTime + 0.5) {
                    return false;
                }
                
                return true;
            }

            renderNote(note, judgeLine, time, parentProps = null) {
                if (!note || !judgeLine) return;
                const judgeProps = this.getJudgeLinePropertiesWithParent(judgeLine, time, parentProps);
                
                // 检查note是否应该显示
                if (!this.shouldNoteBeVisible(note, judgeProps, time)) return;

                const startTime = note.startTime || 0;
                const endTime = note.endTime || startTime;
                const timeToHit = startTime - time;

                const speed = (note.speed || 1) * (judgeProps.speed || 1) * speedMultiplier * BASE_SPEED * 10;
                const distance = timeToHit * speed / 1000;
                const above = note.above !== undefined ? note.above : 1;
                const yOffset = note.yOffset || 0;

                let noteY, noteHeight;
                const noteType = note.type || 1;
                
                if (noteType === 2 && note.endTime) {
                    const holdDuration = endTime - startTime;
                    const timeToEnd = endTime - time;
                    
                    if (time < startTime) {
                        const headDistance = timeToHit * speed / 1000;
                        const tailDistance = timeToEnd * speed / 1000;
                        noteY = judgeProps.y + (above === 1 ? (headDistance + tailDistance) / 2 : -(headDistance + tailDistance) / 2) + yOffset;
                        noteHeight = Math.abs(headDistance - tailDistance);
                    } else if (time >= startTime && time <= endTime) {
                        noteY = judgeProps.y + yOffset;
                        const remainingDistance = timeToEnd * speed / 1000;
                        noteHeight = remainingDistance;
                    } else return;
                } else {
                    noteY = judgeProps.y + (above === 1 ? distance : -distance) + yOffset;
                    noteHeight = 0;
                }

                const noteX = judgeProps.x + (note.positionX || 0);
                const x = this.transformX(noteX);
                const y = this.transformY(noteY);

                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.rotate((judgeProps.rotation + judgeProps.parentRotation) * Math.PI / 180);
                const noteAlpha = note.alpha !== undefined ? note.alpha : 255;
                
                // 应用判定线透明度到note上
                let finalAlpha = noteAlpha / 255;
                if (judgeProps.alpha > 0) {
                    finalAlpha *= (judgeProps.alpha / 255);
                }
                this.ctx.globalAlpha = Math.max(0, Math.min(1, finalAlpha));
                
                this.drawNote(note, noteHeight);
                this.ctx.restore();
            }

            drawNote(note, holdHeight = 0) {
                const baseSize = this.noteSize * noteSizeFactor;
                const size = (note.size || 1) * baseSize;
                const noteType = note.type || 1;
                const isDouble = note.isDouble === true || note.isDouble === 1;
                const textureInfo = NOTE_TEXTURES[noteType];
                const textureName = textureInfo ? (isDouble ? textureInfo.double : textureInfo.single) : 'Tap.png';
                const texture = noteTextures[textureName];

                if (texture && texture.complete) {
                    const aspectRatio = texture.width / texture.height;
                    let width = size, height = size;
                    if (aspectRatio > 1) height = size / aspectRatio; else width = size * aspectRatio;
                    if (noteType === 2) { width *= 2; height = holdHeight > 0 ? Math.max(holdHeight, height / 4) : height / 4; }
                    this.ctx.drawImage(texture, -width/2, -height/2, width, height);
                } else {
                    const tint = note.tint || [255, 255, 255];
                    this.ctx.fillStyle = `rgb(${tint[0]}, ${tint[1]}, ${tint[2]})`;
                    switch(noteType) {
                        case 1: this.ctx.fillRect(-size/2, -size/2, size, size); break;
                        case 2: 
                            const holdWidth = size * 2;
                            const holdH = holdHeight > 0 ? Math.max(holdHeight, size/4) : size/4;
                            this.ctx.fillRect(-holdWidth/2, -holdH/2, holdWidth, holdH);
                            break;
                        case 3: 
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                            this.ctx.fill();
                            break;
                        case 4:
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, -size/2);
                            this.ctx.lineTo(size/2, 0);
                            this.ctx.lineTo(0, size/2);
                            this.ctx.lineTo(-size/2, 0);
                            this.ctx.closePath();
                            this.ctx.fill();
                            break;
                        default: this.ctx.fillRect(-size/2, -size/2, size, size);
                    }
                }
            }

            render(time) {
                this.ctx.fillStyle = '#2a2d3e';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                if (!this.chartData || !this.chartData.judgeLineList) return;

                try {
                    hitNoteCount = 0;
                    const judgeLines = [...this.chartData.judgeLineList]
                        .map((line, index) => ({ line, zOrder: line.zOrder || 0, index }))
                        .sort((a, b) => a.zOrder - b.zOrder || a.index - b.index)
                        .map(item => item.line);

                    // 先统计已过线的note数量
                    const countHitNotes = (judgeLine, parentProps = null) => {
                        if (!judgeLine || !judgeLine.notes) return;
                        const judgeProps = this.getJudgeLinePropertiesWithParent(judgeLine, time, parentProps);
                        
                        for (let i = 0; i < judgeLine.notes.length; i++) {
                            const note = judgeLine.notes[i];
                            const startTime = note.startTime || 0;
                            if (time >= startTime) {
                                const isFake = note.isFake === true || note.isFake === 1;
                                if (!isFake) hitNoteCount++;
                            }
                        }
                        
                        if (judgeLine.judgeLineList) {
                            for (let i = 0; i < judgeLine.judgeLineList.length; i++) {
                                const childProps = this.getJudgeLinePropertiesWithParent(judgeLine.judgeLineList[i], time, parentProps);
                                countHitNotes(judgeLine.judgeLineList[i], childProps);
                            }
                        }
                    };

                    for (let i = 0; i < judgeLines.length; i++) {
                        countHitNotes(judgeLines[i]);
                    }

                    document.getElementById('hitNoteDisplay').textContent = `已过线Note: ${hitNoteCount}`;

                    // 渲染所有判定线和note
                    for (let i = 0; i < judgeLines.length; i++) {
                        this.renderJudgeLine(judgeLines[i], time);
                    }
                } catch (error) {
                    console.error('渲染错误:', error);
                }
            }

            setChartData(chartData) { this.chartData = chartData; }
            setNoteSize(factor) { this.noteSize = 75 * factor * 2; }
        }

        // 工具函数
        function beatToValue(beat) {
            if (!Array.isArray(beat) || beat.length < 3) return 0;
            return beat[0] + beat[1] / (beat[2] || 1);
        }

        function beat2sec(BPMList, beat, bpmfactor = 1) {
            if (!BPMList) return 0;
            let targetBeat = beatToValue(beat);
            let sec = 0, remainingBeat = targetBeat;
            for (let i = 0; i < BPMList.length; i++) {
                const bpm = BPMList[i];
                if (!bpm || typeof bpm.bpm !== 'number') continue;
                const bpmValue = bpm.bpm / bpmfactor;
                const currentStart = beatToValue(bpm.startTime || [0, 0, 1]);
                if (i < BPMList.length - 1) {
                    const nextBPM = BPMList[i + 1];
                    if (!nextBPM) continue;
                    const nextStart = beatToValue(nextBPM.startTime || [0, 0, 1]);
                    const segmentLength = nextStart - currentStart;
                    if (remainingBeat > segmentLength) {
                        sec += segmentLength * (60 / bpmValue);
                        remainingBeat -= segmentLength;
                    } else {
                        sec += remainingBeat * (60 / bpmValue);
                        remainingBeat = 0;
                        break;
                    }
                } else {
                    sec += remainingBeat * (60 / bpmValue);
                    break;
                }
            }
            return sec;
        }

        function allbeat2sec(rpeData) {
            if (!rpeData) return rpeData;
            try {
                const result = JSON.parse(JSON.stringify(rpeData));
                function processObject(obj) {
                    if (!obj || typeof obj !== 'object') return;
                    for (let key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            if ((key === "startTime" || key === "endTime") && Array.isArray(obj[key])) {
                                obj[key] = beat2sec(rpeData.BPMList, obj[key]);
                            } else if (typeof obj[key] === "object") {
                                processObject(obj[key]);
                            }
                        }
                    }
                }
                for (let key in result) {
                    if (key !== "BPMList" && typeof result[key] === "object") {
                        processObject(result[key]);
                    }
                }
                return result;
            } catch (error) {
                console.error("谱面时间转换错误:", error);
                return rpeData;
            }
        }

        function formatTime(time) {
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            const milliseconds = Math.floor((time * 1000) % 1000);
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }

        function retryLoadTexture(url, textureName, isJudgeLine = false) {
            const img = new Image();
            if (isJudgeLine) judgeLineTextures[textureName] = img;
            else noteTextures[textureName] = img;
            img.onload = () => console.log(`材质加载成功: ${textureName}`);
            img.onerror = () => console.warn(`材质加载失败: ${textureName}`);
            img.src = url;
        }

        function preloadTextures() {
            for (const [type, textures] of Object.entries(NOTE_TEXTURES)) {
                for (const [key, filename] of Object.entries(textures)) {
                    retryLoadTexture(`./assets/${filename}`, filename, false);
                }
            }
        }

        async function loadJudgeLineTexturesFromZip() {
            for (const [path, url] of Object.entries(ChartJSON)) {
                if (path.match(/\.(png|jpg|jpeg|gif|bmp|webp)$/i)) {
                    retryLoadTexture(url, path, true);
                }
            }
        }

        function setupAudio(songFile) {
            if (audioElement) {
                audioElement.pause();
                audioElement = null;
            }
            if (songFile && ChartJSON[songFile]) {
                audioElement = document.getElementById('audioControl');
                audioElement.src = ChartJSON[songFile];
                audioElement.load();
                audioElement.addEventListener('timeupdate', function() {
                    if (isRunning && audioElement) {
                        currentTime = audioElement.currentTime;
                        elapsedTime = currentTime * 1000;
                        startTime = Date.now() - elapsedTime;
                        document.getElementById('timeDisplay').textContent = formatTime(currentTime);
                    }
                });
            }
        }

        function init() {
            const canvas = document.getElementById('player');
            if (!canvas) return;
            renderer = new PhigrosRenderer(canvas);
            isInitialized = true;
        }

        function start() {
            if (!isInitialized) init();
            if (!chartContent) { alert("请先加载谱面文件"); return; }
            
            try {
                if (!chartData) {
                    chartData = JSON.parse(chartContent);
                    const convertedData = allbeat2sec(chartData);
                    if (renderer) {
                        renderer.setChartData(convertedData);
                        renderer.setNoteSize(noteSizeFactor);
                    }
                }
                
                if (!isRunning) {
                    isRunning = true;
                    startTime = Date.now() - elapsedTime;
                    
                    // 直接开始动画循环
                    function animate() {
                        if (!isRunning) return;
                        const now = Date.now();
                        elapsedTime = now - startTime;
                        currentTime = elapsedTime / 1000;
                        document.getElementById('timeDisplay').textContent = formatTime(currentTime);
                        if (renderer) renderer.render(currentTime);
                        animationFrameId = requestAnimationFrame(animate);
                    }
                    
                    // 开始动画
                    animate();
                    
                    // 尝试播放音频
                    if (audioFile) {
                        setupAudio(audioFile);
                        if (audioElement) {
                            audioElement.currentTime = currentTime;
                            audioElement.play().catch(e => {
                                console.warn('自动播放被阻止:', e);
                            });
                        }
                    }
                    
                    document.getElementById('pauseBtn').textContent = "暂停";
                }
            } catch (e) {
                console.error("解析JSON失败:", e);
                alert("谱面数据格式错误");
            }
        }

        function pause() {
            const pauseBtn = document.getElementById('pauseBtn');
            if (isRunning) {
                isRunning = false;
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                if (audioElement) audioElement.pause();
                elapsedTime = Date.now() - startTime;
                pauseBtn.textContent = "继续";
            } else {
                isRunning = true;
                startTime = Date.now() - elapsedTime;
                if (audioElement) audioElement.play().catch(e => console.warn('音频播放失败:', e));
                pauseBtn.textContent = "暂停";
                requestAnimationFrame(function animate() {
                    if (!isRunning) return;
                    const now = Date.now();
                    elapsedTime = now - startTime;
                    currentTime = elapsedTime / 1000;
                    document.getElementById('timeDisplay').textContent = formatTime(currentTime);
                    if (renderer) renderer.render(currentTime);
                    animationFrameId = requestAnimationFrame(animate);
                });
            }
        }

        function reset() {
            isRunning = false;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (audioElement) { audioElement.pause(); audioElement.currentTime = 0; }
            elapsedTime = 0; currentTime = 0; hitNoteCount = 0;
            document.getElementById('timeDisplay').textContent = "00:00.000";
            document.getElementById('hitNoteDisplay').textContent = "已过线Note: 0";
            document.getElementById('pauseBtn').textContent = "暂停";
            if (renderer && chartData) {
                try {
                    const convertedData = allbeat2sec(chartData);
                    renderer.setChartData(convertedData);
                    renderer.render(0);
                } catch (e) { console.error("重置失败:", e); }
            }
        }

        function exIt() {
            isRunning = false;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (audioElement) { audioElement.pause(); audioElement = null; }
            elapsedTime = 0; currentTime = 0; hitNoteCount = 0;
            chartData = null;
            document.getElementById('timeDisplay').textContent = "00:00.000";
            document.getElementById('hitNoteDisplay').textContent = "已过线Note: 0";
            document.getElementById('pauseBtn').textContent = "暂停";
            if (renderer) { renderer.setChartData(null); renderer.render(0); }
        }

        function toggleFullscreen() {
            const container = document.getElementById('playerContainer');
            const canvas = document.getElementById('player');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            if (!document.fullscreenElement) {
                container.requestFullscreen().then(() => {
                    fullscreenBtn.style.display = 'none';
                    canvas.style.width = '100vw';
                    canvas.style.height = '100vh';
                });
            } else {
                document.exitFullscreen().then(() => {
                    fullscreenBtn.style.display = 'block';
                    canvas.style.width = '720px';
                    canvas.style.height = '540px';
                });
            }
        }

        async function handleZipFile(file) {
            if (!file) { alert("请选择有效的ZIP文件"); return; }
            if (typeof JSZip === 'undefined') { alert("JSZip库未加载"); return; }
            try {
                document.getElementById('loading').classList.remove('hidden');
                const zip = new JSZip();
                const contents = await zip.loadAsync(file);
                const promises = [];
                contents.forEach((path, entry) => {
                    if (!entry.dir) {
                        promises.push(entry.async('blob').then(blob => {
                            ChartJSON[path] = URL.createObjectURL(blob);
                        }));
                    }
                });
                await Promise.all(promises);
                await loadJudgeLineTexturesFromZip();
                await InfoRequest();
            } catch (err) {
                console.error("ZIP文件处理失败:", err);
                alert("ZIP文件处理失败");
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }

        async function InfoRequest() {
            if (ChartJSON['info.txt']) {
                try {
                    const response = await fetch(ChartJSON['info.txt']);
                    const text = await response.text();
                    const chartInfo = {};
                    const lines = text.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('#')) continue;
                        const match = line.match(/(\w+):\s*(.+)/);
                        if (match) {
                            const key = match[1].trim();
                            const value = match[2].trim();
                            chartInfo[key] = value;
                            if (key.toLowerCase() === 'song') audioFile = value;
                        }
                    }
                    document.getElementById('chartName').value = chartInfo.Name || '';
                    document.getElementById('chartDifficulty').value = chartInfo.Level || '';
                    if (chartInfo.Chart && ChartJSON[chartInfo.Chart]) {
                        const chartResponse = await fetch(ChartJSON[chartInfo.Chart]);
                        chartContent = await chartResponse.text();
                    }
                } catch (err) {
                    console.error("加载谱面信息失败:", err);
                }
            }
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            preloadTextures();
            document.getElementById('speedControl').addEventListener('input', function() {
                speedMultiplier = parseFloat(this.value);
                document.getElementById('speedValue').textContent = speedMultiplier.toFixed(1);
            });
            document.getElementById('noteSizeControl').addEventListener('input', function() {
                noteSizeFactor = parseFloat(this.value) / 100;
                document.getElementById('noteSizeValue').textContent = this.value + '%';
                if (renderer) renderer.setNoteSize(noteSizeFactor);
            });
            document.getElementById('zipFile').addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (file) handleZipFile(file);
            });
            init();
        });
    </script>
    <script src="js/jszip.min.js"></script>
</body>
</html>
